{"version":3,"sources":["../../../src/Apps/Order/getRedirect.ts"],"names":["trimLeadingSlashes","s","replace","getRedirect","redirects","location","args","trimmedLocation","rules","rule","redirect","length","children","matchingChild","filter","child","startsWith","path","sort","a","b","split","pop","slice"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAaO,IAAMA,kBAAkB,GAAG,SAArBA,kBAAqB,CAACC,CAAD;AAAA,SAAeA,CAAC,CAACC,OAAF,CAAU,MAAV,EAAkB,EAAlB,CAAf;AAAA,CAA3B;;;;AAEA,SAASC,WAAT,CACLC,SADK,EAELC,QAFK,EAGLC,IAHK,EAIY;AACjB,MAAMC,eAAe,GAAGP,kBAAkB,CAACK,QAAD,CAA1C;AADiB;AAAA;AAAA;;AAAA;AAGjB,yBAAmBD,SAAS,CAACI,KAA7B,8HAAoC;AAAA,UAAzBC,IAAyB;AAClC,UAAMC,QAAQ,GAAGD,IAAI,CAACH,IAAD,CAArB;;AACA,UAAII,QAAJ,EAAc;AACZ,eAAOA,QAAP;AACD;AACF;AARgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAUjB,MAAIH,eAAe,CAACI,MAAhB,GAAyB,CAAzB,IAA8BP,SAAS,CAACQ,QAA5C,EAAsD;AACpD;AACA,QAAMC,aAAa,GAAGT,SAAS,CAACQ,QAAV,CACnBE,MADmB,CACZ,UAAAC,KAAK;AAAA,aAAIR,eAAe,CAACS,UAAhB,CAA2BD,KAAK,CAACE,IAAjC,CAAJ;AAAA,KADO,EAEnBC,IAFmB,CAEd,UAACC,CAAD,EAAIC,CAAJ;AAAA,aAAUD,CAAC,CAACF,IAAF,CAAOI,KAAP,CAAa,GAAb,EAAkBV,MAAlB,GAA2BS,CAAC,CAACH,IAAF,CAAOI,KAAP,CAAa,GAAb,EAAkBV,MAAvD;AAAA,KAFc,EAGnBW,GAHmB,EAAtB;;AAIA,QAAIT,aAAJ,EAAmB;AACjB,aAAOV,WAAW,CAChBU,aADgB,EAEhBN,eAAe,CAACgB,KAAhB,CAAsBV,aAAa,CAACI,IAAd,CAAmBN,MAAzC,CAFgB,EAGhBL,IAHgB,CAAlB;AAKD;AACF;;AAED,SAAO,IAAP;AACD","sourcesContent":["export interface Redirect {\n  path: string\n  reason: string\n}\n\nexport type RedirectPredicate<Arguments> = (args: Arguments) => Redirect | void\n\nexport interface RedirectRecord<Arguments> {\n  path: string\n  rules: Array<RedirectPredicate<Arguments>>\n  children?: Array<RedirectRecord<Arguments>>\n}\n\nexport const trimLeadingSlashes = (s: string) => s.replace(/^\\/+/, \"\")\n\nexport function getRedirect<Arguments>(\n  redirects: RedirectRecord<Arguments>,\n  location: string,\n  args: Arguments\n): Redirect | null {\n  const trimmedLocation = trimLeadingSlashes(location)\n\n  for (const rule of redirects.rules) {\n    const redirect = rule(args)\n    if (redirect) {\n      return redirect\n    }\n  }\n\n  if (trimmedLocation.length > 0 && redirects.children) {\n    // find most specific matching child (i.e. longest path match)\n    const matchingChild = redirects.children\n      .filter(child => trimmedLocation.startsWith(child.path))\n      .sort((a, b) => a.path.split(\"/\").length - b.path.split(\"/\").length)\n      .pop()\n    if (matchingChild) {\n      return getRedirect(\n        matchingChild,\n        trimmedLocation.slice(matchingChild.path.length),\n        args\n      )\n    }\n  }\n\n  return null\n}\n"],"file":"getRedirect.js"}