{"version":3,"sources":["../../../src/DevTools/createMockNetworkLayer/index.ts"],"names":["createMockNetworkLayer","mockResolvers","Network","create","schema","mocks","FormattedNumber","createMockNetworkLayer2","mockData","mockMutationResults","createMockFetchQuery","idMap","WeakMap","fieldResolver","source","_args","_context","info","pathAsArray","path","length","operation","parentPath","slice","join","operationName","i","name","value","Error","alias","fieldNodes","inferUnionOrInterfaceType","checkLeafType","fieldName","id","has","get","set","error","type","resolvers","Query","Object","entries","reduce","acc","k","v","Mutation","returnType","parseValue","e","ofType","unionMemberTypes","getPossibleTypes","keys","key","matchingTypes","filter","getFields","__typename","possibleTypes","map","renderMessage","inspect"],"mappings":"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","sourcesContent":["import {\n  GraphQLFieldResolver,\n  GraphQLResolveInfo,\n  isAbstractType,\n  isLeafType,\n  isNonNullType,\n  responsePathAsArray,\n} from \"graphql\"\nimport { IMocks } from \"graphql-tools/dist/Interfaces\"\nimport getNetworkLayer from \"relay-mock-network-layer\"\nimport { Network, RelayNetwork } from \"relay-runtime\"\nimport { get } from \"Utils/get\"\nimport uuid from \"uuid\"\nimport schema from \"../../../data/schema.graphql\"\nimport FormattedNumber from \"./CustomScalars/formatted_number\"\n\n/**\n * @deprecated use createMockNetworkLayer2\n * @param mockResolvers\n */\nexport const createMockNetworkLayer = (mockResolvers: IMocks) => {\n  return Network.create(\n    getNetworkLayer({\n      schema,\n      mocks: { FormattedNumber: () => FormattedNumber, ...mockResolvers },\n    })\n  )\n}\n\nexport const createMockNetworkLayer2 = ({\n  mockData = {},\n  mockMutationResults = {},\n}: {\n  mockData?: object\n  mockMutationResults?: object\n}): RelayNetwork => {\n  return Network.create(createMockFetchQuery({ mockData, mockMutationResults }))\n}\n\n/**\n * Here we create a mock for the `fetchQuery` graphql helper which executes\n * a query. The mock is injected with fake results.\n * @param param0\n */\nexport const createMockFetchQuery = ({\n  mockData = {},\n  mockMutationResults = {},\n}: {\n  mockData?: object\n  mockMutationResults?: object\n}) => {\n  const idMap = new WeakMap()\n  // getNetworkLayer is quite poorly named. It's actually returning a\n  // `fetchQuery` function\n  return getNetworkLayer({\n    // We pass this field resolver in so that we can control the resolution\n    // logic for all data that relay tries to extract from our mock fixtures.\n    fieldResolver: ((source, _args, _context, info) => {\n      const pathAsArray = responsePathAsArray(info.path)\n      if (pathAsArray.length === 1) {\n        // source is null for root fields\n        source =\n          source ||\n          (info.operation.operation === \"mutation\"\n            ? mockMutationResults\n            : mockData)\n      }\n\n      // fail early if source is not an object type\n      // this happens because graphql only checks for null when deciding\n      // whether to resolve fields in a given value\n      if (typeof source !== \"object\") {\n        const parentPath = pathAsArray.slice(0, -1).join(\"/\")\n        const operationName = get(info, i => i.operation.name.value)\n        throw new Error(\n          `The value at path '${parentPath}' for operation '${operationName}' should be an object but is a ${typeof source}.`\n        )\n      }\n\n      // handle aliased fields first\n      const alias = info.fieldNodes[0].alias\n      if (alias && alias.value in source) {\n        return inferUnionOrInterfaceType(\n          checkLeafType(source[alias.value], info),\n          info\n        )\n      }\n\n      // the common case, the field has a fixture and is not aliased\n      if (info.fieldName in source) {\n        return inferUnionOrInterfaceType(\n          checkLeafType(source[info.fieldName], info),\n          info\n        )\n      }\n\n      if (info.fieldName === \"__id\" || info.fieldName === \"id\") {\n        // if relay is looking for `__id` but we only supplied `id`\n        if (\"id\" in source) {\n          return source.id\n        }\n\n        // relay is looking for an id to denormalize the fixture in the store\n        // but we don't want to have to specify ids for all fixtures\n        // so generate one and store it in a weak map so we don't mutate\n        // the object itself\n        if (idMap.has(source)) {\n          return idMap.get(source)\n        }\n\n        const id = uuid()\n        idMap.set(source, id)\n        return id\n      }\n\n      throw error(\n        info,\n        ({ type, path, operationName }) =>\n          `A mock for field at path '${path}' of type '${type}' was expected for operation '${operationName}', but none was found.`\n      )\n    }) as GraphQLFieldResolver<any, any>,\n    schema,\n    resolvers: {\n      FormattedNumber: () => FormattedNumber,\n      // here we map the mock fixture entries to resolver functions if they aren't\n      // already. graphql-tools expects functions, but we want to be able to just\n      // supply plain data for syntax convenience.\n      Query: Object.entries(mockData).reduce(\n        (acc, [k, v]) => ({\n          ...acc,\n          [k]: typeof v === \"function\" ? v : () => v,\n        }),\n        {}\n      ),\n      Mutation: Object.entries(mockMutationResults).reduce(\n        (acc, [k, v]) => ({\n          ...acc,\n          [k]: typeof v === \"function\" ? v : () => v,\n        }),\n        {}\n      ),\n    },\n  })\n}\n\nconst checkLeafType = (value: unknown, info: GraphQLResolveInfo) => {\n  const returnType = info.returnType\n  if (isLeafType(returnType)) {\n    try {\n      returnType.parseValue(value)\n    } catch (e) {\n      throw error(\n        info,\n        ({ type, path, operationName }) =>\n          `Expected mock value of type '${type}' but got '${typeof value}' at path '${path}' for operation '${operationName}'`\n      )\n    }\n  }\n  return value\n}\n\n// This function tries to infer the concrete type of a value that appears\n// in a position whose type is either a union or an interface\nconst inferUnionOrInterfaceType = (\n  value: unknown,\n  info: GraphQLResolveInfo\n) => {\n  let returnType = info.returnType\n\n  if (isNonNullType(returnType)) {\n    returnType = returnType.ofType\n  }\n\n  if (!isAbstractType(returnType)) {\n    return value\n  }\n\n  // remember that typeof null === 'object'\n  if (typeof value !== \"object\") {\n    throw error(\n      info,\n      ({ type, path, operationName }) =>\n        `Expected object of type '${type}' but got '${typeof value}' at path '${path}' for operation '${operationName}'`\n    )\n  }\n\n  if (value == null || \"__typename\" in value) {\n    return value\n  }\n\n  const unionMemberTypes = info.schema.getPossibleTypes(returnType)\n\n  // try to find keys in the object which are unique to one type\n  for (const key of Object.keys(value)) {\n    const matchingTypes = unionMemberTypes.filter(type => type.getFields()[key])\n    if (matchingTypes.length === 1) {\n      return { ...value, __typename: matchingTypes[0].name }\n    }\n  }\n\n  // failed to find unique keys so the object is ambiguous and we need to ask for a __typename\n  const possibleTypes = unionMemberTypes.map(type => type.name).join(\", \")\n  throw error(\n    info,\n    ({ path, operationName }) =>\n      `Ambiguous object at path '${path}' for operation '${operationName}'. Add a __typename from this list: [${possibleTypes}]`\n  )\n}\n\nfunction error(\n  info: GraphQLResolveInfo,\n  renderMessage: (args: {\n    type: string\n    path: string\n    operationName: string\n  }) => string\n) {\n  return new Error(\n    renderMessage({\n      path: responsePathAsArray(info.path).join(\"/\"),\n      type: info.returnType.inspect(),\n      operationName: get(info, i => i.operation.name.value, \"(unknown)\"),\n    })\n  )\n}\n"],"file":"index.js"}