{"version":3,"sources":["../../src/DevTools/createTestEnv.tsx"],"names":["Mutations","resolvers","mutationResults","Object","entries","forEach","k","v","mockImplementationOnce","mockReturnValueOnce","mockFetch","Promise","reject","Error","jest","fn","mock","calls","length","Routes","TestEnv","opts","mockData","mockMutationResults","breakpoint","Component","TestPage","query","defaultData","defaultBreakpoint","page","mutations","useResultsOnce","fetchQuery","wrappedFetchQuery","operation","variables","catch","e","errors","push","mockImplementation","mockNetwork","Network","create","variableValues","operationKind","props","contextBypass","SystemContext","headTags","routes","mockPushRoute","onTransition","mockOnTransition","root","mutationResolvers","defaultMutationResults","reduce","acc","beforeEach","afterEach","_errors","mockClear","keys","key","createTestEnv"],"mappings":"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","sourcesContent":["import { ConnectedModalDialog } from \"Apps/Order/Dialogs\"\nimport { SystemContext } from \"Artsy\"\nimport { createMockFetchQuery, MockBoot, renderRelayTree } from \"DevTools\"\nimport React, { ReactElement, useContext } from \"react\"\nimport { GraphQLTaggedNode } from \"react-relay\"\nimport { Network } from \"relay-runtime\"\nimport { Breakpoint } from \"Utils/Responsive\"\nimport { RootTestPage } from \"./RootTestPage\"\n\nclass Mutations<MutationNames extends string> {\n  constructor(\n    /**\n     * resolvers is an object which maps mutation names to jest.Mock functions\n     * Use this if you want to intercept resolution on the fly.\n     *\n     * e.g. mutations.resolvers.createCreditCard.mockImplementationOnce(...)\n     */\n    public resolvers: Record<MutationNames, jest.Mock>\n  ) {\n    this.resolvers = resolvers\n  }\n  /**\n   * useResultsOnce\n   * @param muationResults an object which should look like the json returned by\n   * metaphysics after executing a mutation\n   */\n  useResultsOnce = (mutationResults: Partial<Record<MutationNames, any>>) => {\n    Object.entries(mutationResults).forEach(([k, v]) => {\n      if (typeof v === \"function\") {\n        this.resolvers[k].mockImplementationOnce(v)\n      } else {\n        this.resolvers[k].mockReturnValueOnce(v)\n      }\n    })\n  }\n\n  mockNetworkFailureOnce = () => {\n    this.mockFetch.mockImplementationOnce(() =>\n      Promise.reject(new Error(\"failed to fetch\"))\n    )\n  }\n\n  get lastFetchVariables() {\n    return this.mockFetch.mock.calls[this.mockFetch.mock.calls.length - 1][1]\n  }\n\n  readonly mockFetch = jest.fn()\n}\n\nclass Routes {\n  mockPushRoute = jest.fn()\n  mockOnTransition = jest.fn()\n}\n\nclass TestEnv<MutationNames extends string, TestPage extends RootTestPage> {\n  constructor(\n    private opts: {\n      Component: React.ComponentType<any>\n      query: GraphQLTaggedNode\n      defaultData: object\n      defaultMutationResults?: Record<MutationNames, any>\n      defaultBreakpoint?: Breakpoint\n      TestPage: { new (): TestPage }\n    }\n  ) {\n    this.opts = opts\n\n    const mutationResolvers: Record<MutationNames, jest.Mock> = Object.entries(\n      opts.defaultMutationResults || {}\n    ).reduce(\n      (acc, [k, v]) => ({\n        ...acc,\n        [k]: jest.fn((...args) => (typeof v === \"function\" ? v(...args) : v)),\n      }),\n      {} as any\n    )\n\n    beforeEach(() => {\n      this.errors = []\n    })\n\n    afterEach(() => {\n      const _errors = this.errors\n      this.errors = []\n      // @ts-ignore\n      this.headTags = []\n      this.mutations.mockFetch.mockClear()\n      this.routes.mockOnTransition.mockClear()\n      this.routes.mockPushRoute.mockClear()\n      Object.keys(mutationResolvers).forEach(key =>\n        mutationResolvers[key].mockClear()\n      )\n      if (_errors.length !== 0) {\n        throw new Error(_errors as any)\n      }\n    })\n\n    this.mutations = new Mutations(mutationResolvers)\n  }\n\n  mutations: Mutations<MutationNames>\n  routes = new Routes()\n  readonly headTags: Array<ReactElement<any>> = []\n\n  private errors: any[] = []\n\n  /**\n   * buildPage\n   * @param opts.mockData supplementary mock data to supply to the page\n   * @param opts.mockMutationResults supplementary mutation results to use\n   * @param opts.breakpoint set the breakpoint for the page\n   */\n  buildPage = async ({\n    mockData,\n    mockMutationResults,\n    breakpoint,\n  }: {\n    mockData?: object\n    mockMutationResults?: Record<MutationNames, any>\n    breakpoint?: Breakpoint\n  } = {}): Promise<TestPage> => {\n    const {\n      Component,\n      // tslint:disable-next-line:no-shadowed-variable\n      TestPage,\n      query,\n      defaultData,\n      defaultBreakpoint,\n    } = this.opts\n    const page = new TestPage() as TestPage\n\n    if (mockMutationResults) {\n      this.mutations.useResultsOnce(mockMutationResults)\n    }\n\n    const fetchQuery = createMockFetchQuery({\n      mockData: { ...defaultData, ...mockData },\n      mockMutationResults: this.mutations.resolvers,\n    })\n\n    // surface resolver errors from fetchQuery that otherwise get swallowed by\n    // error handling in the pages themselves\n    const wrappedFetchQuery = (operation, variables) =>\n      fetchQuery(operation, variables).catch(e => {\n        this.errors.push(e)\n        throw e\n      })\n\n    this.mutations.mockFetch.mockImplementation(wrappedFetchQuery)\n\n    // Switch on mutation/query when making requests to help make assertions\n    // Seems we only make assertions about mutations right now\n    const mockNetwork = Network.create((operation, variableValues) => {\n      return operation.operationKind === \"mutation\"\n        ? this.mutations.mockFetch(operation, variableValues)\n        : wrappedFetchQuery(operation, variableValues)\n    })\n\n    // @ts-ignore\n    page.root = await renderRelayTree({\n      Component: (props: any) => {\n        // MockBoot overwrites system context, but we want to preserve the\n        // context set higher in the tree by MockQueryRenderer\n        const contextBypass = useContext(SystemContext)\n        return (\n          <MockBoot\n            breakpoint={breakpoint || defaultBreakpoint}\n            headTags={this.headTags}\n          >\n            <SystemContext.Provider value={contextBypass}>\n              <Component\n                {...props}\n                router={{ push: this.routes.mockPushRoute }}\n                route={{ onTransition: this.routes.mockOnTransition }}\n              />\n              <ConnectedModalDialog />\n            </SystemContext.Provider>\n          </MockBoot>\n        )\n      },\n\n      query,\n      mockNetwork,\n    })\n\n    return page as any\n  }\n}\n\n/**\n * createTestEnv\n *\n * Creates a testing environment for a relay-powered component. The environment\n * has useful tooling for dealing with relay data. Especially for mocking mutation\n * results and for abstracting away boilerplate.\n *\n\n * @param opts.Component the component to render. Will be passed props\n  `relay: RelayProp`, a mock for `route: { onTransition(cb): void {} }` and a\n  mock for `router: { push(route: string) }, along with any query-derived props`\n * @param opts.query The graphql query for the component\n * @param opts.defaultData The default mock data which metaphysics would return\n * for the given query\n * @param opts.defaultMutationResults The default results which metaphysics would\n * return for any mutations executed on the page. If the component executes mutations\n * and you want to test them, they must be declared here.\n * @param opts.defaultBreakpoint The default breakpoint to render the page at\n * @param opts.TestPage The page wrapper class to use. Must extend RootTestPage\n * TODO: add support for query variables\n */\nexport function createTestEnv<\n  MutationNames extends string,\n  TestPage extends RootTestPage\n>(opts: TestEnv<MutationNames, TestPage>[\"opts\"]) {\n  return new TestEnv(opts)\n}\n"],"file":"createTestEnv.js"}