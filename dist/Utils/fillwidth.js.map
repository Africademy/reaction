{"version":3,"sources":["../../src/Utils/fillwidth.ts"],"names":["MAX_ITERATIONS","resizeHeight","img","dir","width","height","fillwidthDimensions","items","containerWidth","gutter","targetHeight","totalWhitespace","length","widthDiff","dim","currentWidth","sum","dimensions","map","item","id","aspectRatio","node","__id","image","aspect_ratio","url","count","data","console","error","JSON","stringify","Math","floor"],"mappings":"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","sourcesContent":["import { reduce } from \"lodash\"\n\nconst MAX_ITERATIONS = 1000\n\n/**\n * Scales an image object proportionally based on a direction (either -1 or 1)\n * @param img a dimension object that references an artwork image\n * @param dir the direction we need to scale an image, either -1 or 1\n */\nconst resizeHeight = (img, dir) => {\n  img.width += (img.width / img.height) * dir\n  img.height += dir\n}\n\nconst fillwidthDimensions = (\n  items,\n  containerWidth,\n  gutter = 10,\n  targetHeight\n) => {\n  const totalWhitespace = () => {\n    return (items.length - 1) * gutter\n  }\n\n  const widthDiff = dim => {\n    const currentWidth = reduce(\n      dim,\n      (sum, img) => {\n        return sum + img.width\n      },\n      0\n    )\n    return containerWidth - currentWidth - totalWhitespace()\n  }\n\n  // Get initial dimensions based on the targetHeight\n  const dimensions = items.map(item => {\n    let id\n    let aspectRatio\n\n    // Set id and aspectRatio for Relay or publishing\n    if (item.node) {\n      id = item.node.__id\n      aspectRatio = item.node.image && item.node.image.aspect_ratio\n    } else {\n      id = item.url ? item.url : item.image\n      aspectRatio = item.width / item.height\n    }\n\n    return {\n      __id: id,\n      width: targetHeight * aspectRatio,\n      height: targetHeight,\n    }\n  })\n\n  // If the total width difference is too small or negative we need to scale down. If not, scale up.\n  const dir = widthDiff(dimensions) < 1 ? -1 : 1\n\n  // Keep looping until we get an acceptable width difference\n  let count = 0\n  while (widthDiff(dimensions) <= 1) {\n    for (const img of dimensions) {\n      resizeHeight(img, dir)\n      if (widthDiff(dimensions) > 1) {\n        break\n      }\n    }\n    // Seeing as there have been a couple of bugs in this code and there are no proper tests yet, letâ€™s at least make\n    // sure to no longer run into infinite loops.\n    count++\n    if (count === MAX_ITERATIONS) {\n      const data = {\n        items,\n        containerWidth,\n        gutter,\n        targetHeight,\n        dir,\n        dimensions,\n      }\n      console.error(\n        `Was unable to calculate a filling width for data: ${JSON.stringify(\n          data\n        )}`\n      )\n      break\n    }\n  }\n\n  // Round image dimensions to whole numbers\n  for (const img of dimensions) {\n    img.width = Math.floor(img.width)\n    img.height = Math.floor(img.height)\n    if (widthDiff(dimensions) === 0) {\n      break\n    }\n  }\n\n  // Voila, sizes for our images\n  return dimensions\n}\n\nexport default fillwidthDimensions\n"],"file":"fillwidth.js"}